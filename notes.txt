1. To set up these projects with python I need to first make a top level directory
that will hold everything including the virtual environment folder, the .git
folder and the one that is created by Django. Since I have installed the
python3 version of virtualenv it will set the environment up with python3. I
then need to activate the environment. To so this type
`source env/bin/activate`.

After this I need to install Django, this involves first running `pip install
mysqlclient` which acts like the MySQLdb module in python2.7 and is the
recommendation from Django with Python3. Outside the virtual environment I had
to install with `sudo apt-get install python3-dev libmysqlclient-dev`, which
reading the README.md on "githut.com/PyMySQL/mysqlclient-python".

At this point I should be good to go. Meaning to run `python manage.py migrate`

From there I have been following the tutorials.

2. Also need to point out that the variable I assign in the model (classes) will
be used throughout the class with self.[variable] like normal.

3. the list_display page of the admin site can be customized by adding in a
[model]Admin class, which inherits from admin.ModelAdmin to the admin.py
script. The fields themselves can be changed by adding attributes to the
methods which are being listed out, by adding attributes to the method itself
in model.py, just be careful of the indent level.

4. Any default admin template can be overridden. This is done by copying the
original from -- "test_project/env/lib/python3.4/site-packages/django/
               contrib/admin/templates/admin" -- and put into my template
folder in the project. Need to make sure the DIR in setting.py is changed.

5. HOW TEMPLATES WORKS, URL REQUESTS
- First start in the mysite/url.py, this tells Django to search the url after
the domain name and then includes() a path to the specific apps urls.
- At this point the app's(polls/url.py) url's will then take over the searching
of the url from there. When it finds a given pattern it loads in a view from
polls/views.py.
- In the views file there are functions that have to return HttpResponse() or an
Http404. In saying this render is a shortcut which returns a HttpResponse, also
the got_object_or_404 is a shortcut to Python's try: find the object's record in
the database and raise an exception of DoesNotExist(). It is really nice
Django takes care of this.

6. NAMESPACING URLS
This tutorial has only one app. which is polls. In a normal Django project there
could be numerous apps. all with a similar name for the urls. Like a details
page for the polls and one for a blog, or even photos. To make sure Django knows
which template I am referring to, the technique used is namespacing of the root
urls in mysite/urls.py

7. To redirect after successfully dealing with post data it is not just a good
practice in Django to redirect but good for web development

8. I will be using generic views system by Django which is an easier way to write
views. In general I will evaluate whether generic views are good for my project
at the start and not half way through but the tutorial wanted to show the basics
first before speeding the process up. Basic math -> calculator.
- The problem this fixes is to deal with views they are generically searching the
database according to parameters passed in the URL and then loading the template,
and returning the rendered template.

9. We’re using two generic views here: ListView and DetailView. Respectively,
those two views abstract the concepts of “display a list of objects” and
“display a detail page for a particular type of object.”

- Each generic view needs to know what model it will be acting upon. This is
provided using the model attribute.
- The DetailView generic view expects the primary key value captured from the URL
to be called "pk", so we’ve changed question_id to pk for the generic views.

By default, the DetailView generic view uses a template called
<app name>/<model name>_detail.html. In our case, it would use the template
"polls/question_detail.html". The template_name attribute is used to tell Django
to use a specific template name instead of the autogenerated default template
name. We also specify the template_name for the results list view – this ensures
that the results view and the detail view have a different appearance when
rendered, even though they’re both a DetailView behind the scenes.

Similarly, the ListView generic view uses a default template called
<app name>/<model name>_list.html; we use template_name to tell ListView to use
our existing "polls/index.html" template.

In previous parts of the tutorial, the templates have been provided with a
context that contains the question and latest_question_list context variables.
For DetailView the question variable is provided automatically – since we’re
using a Django model (Question), Django is able to determine an appropriate name
for the context variable. However, for ListView, the automatically generated
context variable is question_list. To override this we provide the
ontext_object_name attribute, specifying that we want to use
latest_question_list instead. As an alternative approach, you could change your
templates to match the new default context variables – but it’s a lot easier
to just tell Django to use the variable you want.

More info can be found in a bookmark. Label Generic views.

10. MY CONFUSION ABOUT TESTING VIEWS.
I was confused about the first view test on the view returning no question.
This was due to when working with the setup_test_environment() it does not create
a temporary testing database and therefore was running against the normal
Question database. So I was wondering how this test would pass, until I recalled
that with testing a separate database is made so if no Question is made in that
test method then nothing will be in the database to show on the view.

11. ABOUT QUERYSETS AND THE FILTER() METHOD
When working with the object.get() object.filter() or object.exclude() I can take
the parameter and append to it '__' and a 'Field lookups' from the docs. It is
the MySQL WHERE part. I can also chain them together.